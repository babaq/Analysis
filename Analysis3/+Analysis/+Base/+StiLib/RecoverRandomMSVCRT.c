/* RecoverRandomMSVCRT.c */
/* 2013-01-20 Zhang Li */
#include "mex.h"

/*
 * Recover Random Sequence Generated by MSVCRT rand().
 */

/* Recover Random Sequence */
void RecoverRandom(double seed,double trial,double stin,double *stiseq){
    int i,j,n;
    srand((unsigned int)seed);
    for (i=0;i<trial*stin;i++){
        stiseq[i]=-1;}
    for (i=0;i<trial;i++){
        for (j=0;j<stin;j++){
            do{n=rand()%((unsigned int)stin);}
            while(stiseq[i*((unsigned int)stin)+n]>=0);
            stiseq[i*((unsigned int)stin)+n]=j;
        }
    }
}

/*  the gateway routine.  */
void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[] )
{
  double seed,trial,stin,*stiseq;
  mwSize mrows,ncols;
  /* Check for proper number of arguments. */
  if(nrhs!=3) {
    mexErrMsgTxt("Three input required.");
  } else if(nlhs>1) {
    mexErrMsgTxt("Too many output arguments");
  }
  /* The inputs must be noncomplex scalar doubles.*/
  mrows = mxGetM(prhs[0]);
  ncols = mxGetN(prhs[0]);
  if( !mxIsDouble(prhs[0]) || mxIsComplex(prhs[0]) ||
      !(mrows==1 && ncols==1) ) {
    mexErrMsgTxt("Input must be a noncomplex scalar double.");
  }
  mrows = mxGetM(prhs[1]);
  ncols = mxGetN(prhs[1]);
  if( !mxIsDouble(prhs[1]) || mxIsComplex(prhs[1]) ||
      !(mrows==1 && ncols==1) ) {
    mexErrMsgTxt("Input must be a noncomplex scalar double.");
  }
  mrows = mxGetM(prhs[2]);
  ncols = mxGetN(prhs[2]);
  if( !mxIsDouble(prhs[2]) || mxIsComplex(prhs[2]) ||
      !(mrows==1 && ncols==1) ) {
    mexErrMsgTxt("Input must be a noncomplex scalar double.");
  }
  /* Assign pointers to each input and output. */
  seed = *mxGetPr(prhs[0]);
  trial = *mxGetPr(prhs[1]);
  stin = *mxGetPr(prhs[2]);
  mrows = stin;
  ncols = trial;
  /* Create matrix for the return argument. */
  plhs[0] = mxCreateDoubleMatrix(mrows,ncols,mxREAL);
  stiseq = mxGetPr(plhs[0]);
  /* Call the RecoverRandom subroutine. */
  RecoverRandom(seed,trial,stin,stiseq);
}